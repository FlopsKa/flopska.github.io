<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>flopska.com - computer science</title><link href="https://flopska.com/" rel="alternate"></link><link href="https://flopska.com/feeds/computer-science.atom.xml" rel="self"></link><id>https://flopska.com/</id><updated>2015-04-03T00:00:00+02:00</updated><entry><title>Redis Cluster als Basis für einen verteilten Chat</title><link href="https://flopska.com/redis-cluster-als-basis-fur-einen-verteilten-chat.html" rel="alternate"></link><published>2015-04-03T00:00:00+02:00</published><updated>2015-04-03T00:00:00+02:00</updated><author><name>flopska</name></author><id>tag:flopska.com,2015-04-03:/redis-cluster-als-basis-fur-einen-verteilten-chat.html</id><summary type="html">&lt;p&gt;Wie schreibt man einen ausfallsicheren Chat für ein Uni-Projekt? Der Post detailliert die mögliche Umsetzung eines verteilten Chat-Systems auf Basis von Redis mit einem Java-Client. Der Load Balancer bleibt als Single Point of Failure - eine mögliche Lösung sind &lt;em&gt;Elastic IP&lt;/em&gt; Adressen.&lt;/p&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href="#anforderungen"&gt;Anforderungen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#stack"&gt;Software Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#softwarearchitektur"&gt;Software Architektur&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#hardwarearchitektur"&gt;Hardware Architektur&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ausblick"&gt;Ausblick&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Anforderungen &lt;a id="anforderungen"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mehrere Clients pro Benutzer&lt;/li&gt;
&lt;li&gt;Integrationstest des Servers als Slim Client&lt;/li&gt;
&lt;li&gt;Verlauf abrufbar&lt;/li&gt;
&lt;li&gt;verschiedene Server mit Authorisierung (falls einzelne Komponenten ausfallen immer noch lauffähig)&lt;/li&gt;
&lt;li&gt;Authorisierung an jedem Server möglich&lt;/li&gt;
&lt;li&gt;Persistierung der Nachrichten auf allen Servern/Nodes&lt;/li&gt;
&lt;li&gt;kein Datenschutz&lt;/li&gt;
&lt;li&gt;Clients pullen, Server pushen&lt;/li&gt;
&lt;li&gt;Nachrichten so schnell wie möglich auf alle anderen Server&lt;/li&gt;
&lt;li&gt;alle schreiben an alle (ein "chatroom", broadcast)&lt;/li&gt;
&lt;li&gt;Login mit E-Mail und Password&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Software Stack &lt;a id="stack"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://redis.io/"&gt;redis&lt;/a&gt; wird als zentrale Datenbank für die Benutzer und die gesendeten Nachrichten verwendet. Mit redis 3.0.0 ist clustering und somit der verteilte Einsatz in den &lt;em&gt;stable&lt;/em&gt;-Branch gekommen.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/xetorthio/jedis"&gt;jedis&lt;/a&gt; ist das empfohlene Java Interface für die Kommunikation mit redis.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://restlet.com/"&gt;restlet&lt;/a&gt; stellt ein Framework für RESTful Anwendungen zur Verfügung. Neben dem Server können auch Clients realisiert werden. Diese Funktionalität wird in den Integrationstests verwendet.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://junit.org"&gt;junit&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://hamcrest.org/JavaHamcrest/"&gt;hamcrest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://projectlombok.org/"&gt;lombok&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Software Architektur &lt;a id="softwarearchitektur"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Mit restlet werden zwei Endpunkte für Anfragen zur Verfügung gestellt:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;http://localhost:8182/user/
http://localhost:8182/message/
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;/user/&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;RESTUser&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;json&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;Representation&lt;/span&gt; &lt;span class="nf"&gt;login&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ChatUser&lt;/span&gt; &lt;span class="n"&gt;chatUser&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="nd"&gt;@Post&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;json&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;ChatUser&lt;/span&gt; &lt;span class="nf"&gt;createUser&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ChatUser&lt;/span&gt; &lt;span class="n"&gt;chatUser&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Mit der &lt;em&gt;createUser(ChatUser chatUser)&lt;/em&gt; Methode kann ein neuer Benutzer am System registriert werden. Die E-Mail Adresse ist dabei eindeutig, d.h. es kann pro E-Mail Adresse nur einen Benutzer im System geben. Wird der Nutzer angelegt enthält der Rückgabewert die generierte ID und den Authentifizierungsschlüssel des neuen Benutzers.&lt;/p&gt;
&lt;p&gt;Die &lt;em&gt;login(ChatUser chatUser)&lt;/em&gt; Methode wird zum Einloggen eines Benutzers verwendet. Der Benutzername und das Passwort werden überprüft und bei einer Übereinstimmung wird der entsprechende Authentifizierungsschlüssel als Cookie zurückgegeben. Bei einem Fehler sendet der Server ein HTTP Status &lt;em&gt;401&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;/message/&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;RESTMessage&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Post&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;json&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="nf"&gt;sendMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="nd"&gt;@Get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;json&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;readMessages&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Das Senden einer Nachricht setzt voraus, dass der Benutzer sich vorher authorisiert hat. Das bedeutet, es muss neben der Nachricht auch ein Cookie mit dem Authentifizierungsschlüssel gesendet werden. War das Senden der Nachricht mit &lt;em&gt;sendMessage(Message message)&lt;/em&gt; erfolgreich enthält die zurückgegebene Nachricht den &lt;em&gt;timestamp&lt;/em&gt;, bei dem die Nachricht am Server eingegangen ist.&lt;/p&gt;
&lt;p&gt;Zum Lesen von Nachrichten ist keine Authentifizierung erforderlich. &lt;em&gt;readMessages&lt;/em&gt; liefert alle auf dem Server gespeicherten Nachrichten zurück.&lt;/p&gt;
&lt;h3&gt;Hardware Architektur &lt;a id="hardwarearchitektur"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Die Hardware Architektur" src="https://flopska.com/images/chat_architecture.png"&gt;&lt;/p&gt;
&lt;p&gt;Der Chat verwendet die klassische Architektur für Webapplikationen: Die Anfragen der Nutzer werden von einem Load Balancer entgegen genommen und auf die Web Server verteilt. Soll eine größere Last verarbeitet werden, können weitere Web Server hinzugefügt werden. Die Authentifizierungsinformationen für Benutzer sind clientseitig in Cookies und serverseitig in der Datenbank gespeichert. Somit hält die Webapplikation keinen State: Fällt ein Server aus routet der Load Balancer die Anfragen an einen anderen Server und der Benutzer bemerkt nichts vom Ausfall eines Servers.&lt;/p&gt;
&lt;p&gt;redis cluster hat einen Failover Mechanismus eingebaut: Beim Ausfall eines Masters wird automatisch ein bestehender Slave zum Master. In der verwendeten Konfiguration können also im Besten Fall bis zu drei Datenbankserver ausfallen.&lt;/p&gt;
&lt;h3&gt;Ausblick &lt;a id="ausblick"&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In der oben beschriebenen Konfiguration ist der Load Balancer ein Single Point of Failure. Eine Möglichkeit auf den Ausfall des Load Balancers zu reagieren ist der Einsatz von sogenannten &lt;em&gt;Elastic IP Addresses&lt;/em&gt; (siehe &lt;a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html"&gt;Elastic IP Addresses bei AWS&lt;/a&gt;). Fällt der Load Balancer aus kann seine IP zeitnah einem parallel laufenden Load Balancer zugewiesen werden.&lt;/p&gt;</content></entry><entry><title>Getting started with vagrant and ansible</title><link href="https://flopska.com/getting-started-with-vagrant-and-ansible.html" rel="alternate"></link><published>2014-04-22T00:00:00+02:00</published><updated>2014-04-22T00:00:00+02:00</updated><author><name>flopska</name></author><id>tag:flopska.com,2014-04-22:/getting-started-with-vagrant-and-ansible.html</id><summary type="html">&lt;p&gt;A short summary of the steps necessary to install vagrant on a linux box and to start the first virtual machine with a precise32 base image.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://vagrantup.com"&gt;vagrant&lt;/a&gt; is a tool to create and configure reproducible
development environments. Wat?!&lt;/p&gt;
&lt;p&gt;Using virtual machines as your development environment has got multiple
benefits: When you're a developer it's easy to provide every team member with
the same environment. When your a designer you don't have the hassle of setting
up the workspace and can focus on the design instead. When you're done and want
to deploy your software you can use the same process you used to setup your
virtual machines to provision your production system.&lt;/p&gt;
&lt;h3&gt;Sounds dope. Where can I get some?&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.vagrantup.com/downloads.html"&gt;Download&lt;/a&gt; the vagrant version for
your system and install it. On Ubuntu that's &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo dpkg -i vagrant_1.5.4_x86_64.deb
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Eventually you have to install the virtualbox packages, too. Enter&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install virtualbox
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That's it. Now you're ready to setup your first virtual machine. Keep calm, I
will guide you:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vagrant init hashicorp/precise32 
vagrant up
vagrant ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Easy, heh? We just downloaded an Ubuntu precise image, created a so called
&lt;a href="http://docs.vagrantup.com/v2/vagrantfile/index.html"&gt;Vagrantfile&lt;/a&gt;, booted the
machine and connected to it. Halt the machine by disconnecting from the ssh
session and entering &lt;code&gt;vagrant halt&lt;/code&gt;.&lt;/p&gt;</content></entry><entry><title>Speedup Vagrant Execution With a Ramdisk</title><link href="https://flopska.com/speedup-vagrant-execution-with-a-ramdisk.html" rel="alternate"></link><published>2014-04-02T00:00:00+02:00</published><updated>2014-04-02T00:00:00+02:00</updated><author><name>flopska</name></author><id>tag:flopska.com,2014-04-02:/speedup-vagrant-execution-with-a-ramdisk.html</id><summary type="html">&lt;p&gt;As I am using vagrant for a university project I try to put the virtual machine onto a ramdisk for faster startup times. The post shows that when loading the machine from a ramdisk the startup time does improve. However, the machine itself does not run faster.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Currently I am using &lt;a href="http://www.vagrantup.com/"&gt;vagrant&lt;/a&gt; in conjunction with
&lt;a href="http://www.vagrantup.com/"&gt;ansible&lt;/a&gt; to provide all team members of our
university project with a consistent development and testing environment.
Before I push my changes I want to make sure that every ansible playbook I
wrote is working and idempotent. To achieve this goal I have to test the
scripts a lot and in doing so I spin up a dozen of new machines.&lt;/p&gt;
&lt;p&gt;To be able to run the necessary software the machines have to download a lot of
packages. Some are only available as source and have to be compiled. Because
the bottleneck when running the machines often lies within the HDD I thought it
would be nice to speed it up a bit by putting the virtual machines on a
ramdisk.&lt;/p&gt;
&lt;h3&gt;Setting up the ramdisk&lt;/h3&gt;
&lt;p&gt;In Ubuntu 13.10 'saucy' it is rather simple to set up a ramdisk:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo mkdir /media/ramdisk
sudo mount -t ramfs ramfs /media/ramdisk
sudo chown -R user:group /media/ramdisk
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Please don't store any important information on the ramdisk as the
data is lost when powering off the computer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To automatically mount the partition when booting add this to your
&lt;code&gt;/etc/fstab&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ramfs       /media/ramdisk      ramfs       defaults        0       0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It is not possible to limit the size of the ramdisk. In extreme cases the host
system may run out of memory. &lt;/p&gt;
&lt;h3&gt;Moving vagrant and virtualbox into the RAM&lt;/h3&gt;
&lt;p&gt;Vagrant usually stores it's files in &lt;code&gt;~/.vagrant.d/&lt;/code&gt;. To use another path set
the VAGRANT_HOME environment variable.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cp -r ~/.vagrant.d /media/ramdisk/vagrant_home
export VAGRANT_HOME=/media/ramdisk/vagrant_home
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now you have to change the location of your virtual machines from within
virtualbox. Open the client by entering &lt;code&gt;virtualbox&lt;/code&gt; into the terminal, go to
'File -&amp;gt; Preferences...' and enter your new ramdisk location as 'Default
Machine Folder'.&lt;/p&gt;
&lt;h3&gt;Performance improvements&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;All tests were run with a new Vagrantfile and a 'raring64' box.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Start up time without ramdisk:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;time vagrant up
...
vagrant up  2,63s user 1,99s system 12% cpu 35,825 total
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Start up time with ramdisk:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;time vagrant up
...
vagrant up  2,55s user 2,07s system 17% cpu 26,853 total
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see starting the image from a ramdisk is faster than starting from a
regular HDD. This is the case because vagrant copies the base box (in this case
'raring64') before starting it. However, there are no performance gains while
running the vm (tested with &lt;code&gt;hdparm -Tt /dev/sda&lt;/code&gt;). This is  the case because
virtualbox is already caching the hard drive access into the ram.&lt;/p&gt;</content></entry></feed>